#!/usr/bin/env zsh

source ${DOTFILES}/zsh/prompt/helpers.zsh

__fpath_add "$PROMPT_FUNCTIONS_PATH"
__autoload "$PROMPT_FUNCTIONS_PATH"

autoload -Uz add-zsh-hook

# For git info
autoload -Uz vcs_info
precmd() { vcs_info }
zstyle ':vcs_info:git:*' formats '|  %b'

function top-prompt {
    emulate -L zsh

    local REPLY
    local left="%F{012}    ${${SHELL/#\/bin\//}:u} |   ${TERM_PROGRAM} | ${TERM} %f"
    local right='%F{011}   %w %b |   %T   %f'

    fill-line $left $right ' '

    typeset -g top=$REPLY
}

function mid-prompt {
    emulate -L zsh

    local REPLY; fill-line $PS1_TL $PS1_TR

    typeset -g mid=$REPLY
}

function set-prompt {
    emulate -L zsh

    # Render functional elements
    local php_wgt; php-ver
    local mid; mid-prompt
    local top; top-prompt

    local prompt_dir='%(5~|%-1~/…/%3~|%4~)'

    # Render layout elements
    local bot_left="${PS1_BL} %F{08} ${prompt_dir}%f ${vcs_info_msg_0_} "
    local bot_right=" ${php_wgt} ${PS1_BR}"

    PROMPT=$'\n'${top}$'\n'${mid}$'\n'${bot_left}
    RPROMPT=$bot_right
}

function set-compact-prompt {
    emulate -L zsh

    local REPLY
    fill-line "  ╔" ""

    PROMPT="%F{00}${REPLY}"$'\n'"  ╚   %f"
    RPROMPT=''
}

function zle-line-init {
    emulate -L zsh

    [[ $CONTEXT == start ]] || return 0

    while true; do
        zle .recursive-edit
        local -i ret=$?
        [[ $ret == 0 && $KEYS == $'\4' ]] || break
        [[ -o ignore_eof ]] || exit 0
    done

    local saved_prompt=$PROMPT
    local saved_rprompt=$RPROMPT

    set-compact-prompt
    zle .reset-prompt

    PROMPT=$saved_prompt
    RPROMPT=$saved_rprompt

    if (( ret )); then
        zle .send-break
    else
        zle .accept-line
    fi

    return ret
}

function TRAPWINCH () {
    set-prompt
    zle .reset-prompt
    clear-screen-zle
}

() {
    emulate -L zsh

    add-zsh-hook preexec position-prompt-bottom
    add-zsh-hook precmd set-prompt

    zle -N zle-line-init
    zle -N magic-enter

    bindkey "^M" magic-enter

    set-prompt
    clear-screen
}

