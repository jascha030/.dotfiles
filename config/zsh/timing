#!/usr/bin/env zsh

# Per-command cycle timing instrumentation.
# Toggle with: toggle-timing && exec zsh -l
#
# Wraps precmd/preexec hooks and prompt functions with checkpoints.
# Output: table of elapsed times printed to stderr after each prompt render.

(( DOT_TIMING_ENABLED )) || return 0

zmodload zsh/datetime

# ── Hook functions ─────────────────────────────────────────────────────────────

# Starts timing at the beginning of the precmd cycle.
__dot_timing_precmd_start() {
    dot-timing-start
    dot-timing-mark "precmd:start"
}

# Reports timing at the end of the precmd cycle (after all other precmd hooks).
__dot_timing_precmd_report() {
    dot-timing-mark "precmd:end (prompt eval next)"
    dot-timing-report
}

# Starts a fresh timing session on preexec to capture the accept-line → precmd gap.
__dot_timing_preexec_start() {
    dot-timing-start
    dot-timing-mark "preexec:start"
}

preexec_functions=(__dot_timing_preexec_start "${preexec_functions[@]}")

# ── Register hooks: start FIRST, report LAST ──────────────────────────────────

precmd_functions=(__dot_timing_precmd_start "${precmd_functions[@]}" __dot_timing_precmd_report)

# ── Wrap precmd hooks with timing ──────────────────────────────────────────────

if (( ${+functions[gitstatus_prompt_update]} )); then
    __orig_gitstatus_prompt_update() { ; }
    functions[__orig_gitstatus_prompt_update]=$functions[gitstatus_prompt_update]

    gitstatus_prompt_update() {
        dot-timing-mark "precmd:gitstatus (before)"
        __orig_gitstatus_prompt_update "$@"
        dot-timing-mark "precmd:gitstatus (after)"
    }
fi

if (( ${+functions[_zsh_autosuggest_start]} )); then
    __orig_zsh_autosuggest_start() { ; }
    functions[__orig_zsh_autosuggest_start]=$functions[_zsh_autosuggest_start]

    _zsh_autosuggest_start() {
        dot-timing-mark "precmd:autosuggest (before)"
        __orig_zsh_autosuggest_start "$@"
        dot-timing-mark "precmd:autosuggest (after)"
    }
fi

if (( ${+functions[_zsh_highlight_main__precmd_hook]} )); then
    __orig_zsh_highlight_precmd() { ; }
    functions[__orig_zsh_highlight_precmd]=$functions[_zsh_highlight_main__precmd_hook]

    _zsh_highlight_main__precmd_hook() {
        dot-timing-mark "precmd:syntax-hl (before)"
        __orig_zsh_highlight_precmd "$@"
        dot-timing-mark "precmd:syntax-hl (after)"
    }
fi

if (( ${+functions[mcfly_prompt_command]} )); then
    __orig_mcfly_prompt_command() { ; }
    functions[__orig_mcfly_prompt_command]=$functions[mcfly_prompt_command]

    mcfly_prompt_command() {
        dot-timing-mark "precmd:mcfly (before)"
        __orig_mcfly_prompt_command "$@"
        dot-timing-mark "precmd:mcfly (after)"
    }
fi

# ── Wrap chpwd hooks (only fire on directory change) ───────────────────────────

if (( ${+functions[__zoxide_hook]} )); then
    __orig_zoxide_hook() { ; }
    functions[__orig_zoxide_hook]=$functions[__zoxide_hook]

    __zoxide_hook() {
        dot-timing-mark "chpwd:zoxide (before)"
        __orig_zoxide_hook "$@"
        dot-timing-mark "chpwd:zoxide (after)"
    }
fi

# ── Wrap ZLE accept-line (auto-ls overrides this) ─────────────────────────────

if (( ${+functions[auto-ls]} )); then
    __orig_auto_ls() { ; }
    functions[__orig_auto_ls]=$functions[auto-ls]

    auto-ls() {
        dot-timing-mark "zle:auto-ls (before)"
        __orig_auto_ls "$@"
        dot-timing-mark "zle:auto-ls (after)"
    }

    zle -N auto-ls
    zle -N accept-line auto-ls
fi

# ── Wrap preexec hooks ─────────────────────────────────────────────────────────

# position-prompt-bottom is autoloaded — can't copy the stub.
# Wrap by triggering autoload first, then replacing.
if (( ${+functions[position-prompt-bottom]} )); then
    position-prompt-bottom 2>/dev/null  # trigger autoload resolution

    if [[ "${functions[position-prompt-bottom]}" != *"builtin autoload"* ]]; then
        __orig_position_prompt_bottom() { ; }
        functions[__orig_position_prompt_bottom]=$functions[position-prompt-bottom]

        position-prompt-bottom() {
            dot-timing-mark "preexec:pos-prompt-bottom (before)"
            __orig_position_prompt_bottom "$@"
            dot-timing-mark "preexec:pos-prompt-bottom (after)"
        }
    fi
fi

if (( ${+functions[_zsh_highlight_preexec_hook]} )); then
    __orig_zsh_highlight_preexec() { ; }
    functions[__orig_zsh_highlight_preexec]=$functions[_zsh_highlight_preexec_hook]

    _zsh_highlight_preexec_hook() {
        dot-timing-mark "preexec:syntax-hl (before)"
        __orig_zsh_highlight_preexec "$@"
        dot-timing-mark "preexec:syntax-hl (after)"
    }
fi

# ── Wrap zle-line-init with fine-grained transient prompt timing ────────────────

if (( ${+functions[zle-line-init]} )); then
    zle-line-init() {
        emulate -L zsh

        [[ $CONTEXT == start ]] || return 0

        while true; do
            zle .recursive-edit
            local -i ret=$?
            [[ $ret == 0 && $KEYS == $'\4' ]] || break
            [[ -o ignore_eof ]] || exit 0
        done

        # ── Transient prompt timing (this is the gap zsh-bench captures) ──
        dot-timing-start
        dot-timing-mark "zle-line-init:post-edit"

        local saved_prompt=$PROMPT
        local saved_rprompt=$RPROMPT

        set-compact-prompt
        dot-timing-mark "zle-line-init:set-compact-prompt"

        zle .reset-prompt
        dot-timing-mark "zle-line-init:.reset-prompt"

        PROMPT=$saved_prompt
        RPROMPT=$saved_rprompt

        if (( ret )); then
            zle .send-break
        else
            zle .accept-line
        fi

        dot-timing-mark "zle-line-init:accept-line"
        dot-timing-report "zle-line-init"

        return ret
    }

    zle -N zle-line-init
fi

# ── Wrap set-prompt (only runs on init + TRAPWINCH, not per-command) ───────────

if (( ${+functions[set-prompt]} )); then
    __orig_set_prompt() { ; }
    functions[__orig_set_prompt]=$functions[set-prompt]

    set-prompt() {
        dot-timing-mark "set-prompt (before)"
        __orig_set_prompt "$@"
        dot-timing-mark "set-prompt (after)"
    }
fi
