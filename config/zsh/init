#!/usr/bin/env zsh

#---------------------------------------------------------------------------------------------------------------------#
# By Jascha030                                       Dotfiles                   https://github.io/jascha030/.dotfiles #
#---------------------------------------------------------------------------------------------------------------------#

(( ${+DOT_DATA_DIR} )) || export DOT_DATA_DIR=${XDG_CONFIG_HOME}/datafiles

#- Internally used functions -----------------------------------------------------------------------------------------#

function __fpath_add {
    fpath=( "$@" "${fpath[@]}" )
}

function __path_add {
    path=( "$@" "${path[@]}" )
}

function __autoload {
    local a

    for a in "$@"; do
        [[ -d "$a" ]] && autoload -Uz "$a"/*(.:t)
    done
}

#- All credits to: https://github.com/mroth/evalcache ----------------------------------------------------------------#

function _evalcache () {
    local cmdHash="nohash" data="$*" name

    # use the first non-variable argument as the name
    for name in "$@"; do
        if [ "$name" = "${name#[A-Za-z_][A-Za-z0-9_]*=}" ]; then
            break
        fi
    done

    # if command is a function, include its definition in data
    if typeset -f "$name" > /dev/null; then
        data=${data}$(typeset -f "$name")
    fi

    if builtin command -v md5 > /dev/null; then
        cmdHash=$(echo -n "$data" | md5)
    elif builtin command -v md5sum > /dev/null; then
        cmdHash=$(echo -n "$data" | md5sum | cut -d' ' -f1)
    fi

    local cacheFile="$ZSH_EVALCACHE_DIR/init-${name##*/}-${cmdHash}.sh"

    if [ "$ZSH_EVALCACHE_DISABLE" = "true" ]; then
        eval "${(q)@}"
    elif [ -s "$cacheFile" ]; then
        source "$cacheFile"
    else
        if type "$name" > /dev/null; then
            echo "evalcache: ${name} initialization not cached, caching output of: $*" >&2
            mkdir -p "$ZSH_EVALCACHE_DIR"
            eval "${(q)@}" > "$cacheFile"
            source "$cacheFile"
        else
            echo "evalcache: ERROR: ${name} is not installed or in PATH" >&2
        fi
    fi
}

function _evalcache_clear () {
    rm -i "$ZSH_EVALCACHE_DIR"/init-*.sh
}

#- Init --------------------------------------------------------------------------------------------------------------#

# Homebrew environment
_evalcache /opt/homebrew/bin/brew shellenv

path=(
    "${DOT_PATH_VAR[@]}"
    "${path[@]}"
    "$HOME/.composer/vendor/bin"
)
typeset -aU path

if (( ${+DOT_COMP_DIRS} )); then
    __fpath_add "${DOT_COMP_DIRS[@]}"
fi

__fpath_add "${ZDOTDIR}/zfunc" "${ZDOTDIR}/completions"
__autoload "${ZDOTDIR}/zfunc"

__fpath_add "/opt/homebrew/share/zsh/site-functions"

# Run (bash)compinit for completions.
autoload -Uz compinit
if [[ -n ${ZDOTDIR:-~}/.zcompdump(#qN.mh+24) ]]; then
    compinit -i
else
    compinit -C -i
fi

# Source files that are required early.
(( ${+DOT_SOURCES} )) && safe_source "${DOT_SOURCES[@]}"

autoload -U +X bashcompinit && bashcompinit
(( ${+DOT_BASH_COMPLETIONS})) && safe_source "${DOT_BASH_COMPLETIONS[@]}"

# Load plugins.
safe_source "$ZDOTDIR"/plugins-spec
[[ "$ZDOTDIR"/.zcompdump.zwc -nt "$ZDOTDIR"/.zcompdump ]] || zcompile_many "$ZDOTDIR"/.zcompdump
unfunction zcompile_many

# Assure required dirs and files exist.
assert_dirs "$DOT_DATA_DIR"
assert_files "${DOT_DATA_DIR}/.zsh_history" "${DOT_DATA_DIR}/.mysql_history"

(( ${+DOT_REQUIRED_DIRS} )) && assert_dirs "${DOT_REQUIRED_DIRS[@]}"
(( ${+DOT_REQUIRED_FILES} )) && assert_files "${DOT_REQUIRED_FILES[@]}"

export ZSH_AUTOSUGGEST_MANUAL_REBIND=1

#- Application init evaluations --------------------------------------------------------------------------------------#

# _evalcache teleport-dir init
_evalcache zoxide init zsh
_evalcache op completion zsh

__auto_opam_env() {
    if [[ -f opam ]] && [[ -z "$OPAM_SWITCH_PREFIX" ]]; then
        _evalcache opam env
    fi
}

autoload -Uz add-zsh-hook
add-zsh-hook chpwd __auto_opam_env

if command -v symfony-autocomplete >/dev/null 2>&1; then
    __lazy_symfony_composer() {
        unfunction __lazy_symfony_composer
        _evalcache symfony-autocomplete composer                    # Load cached completion
        compdef _composer composer __icomposer vcomposer            # Attach real completion to all commands
    }

    __lazy_symfony_valet() {
        unfunction __lazy_symfony_valet
        _evalcache symfony-autocomplete valet
        compdef _valet valet
    }

    __lazy_symfony_phpactor() {
        unfunction __lazy_symfony_phpactor
        _evalcache symfony-autocomplete phpactor
        compdef _phpactor phpactor
    }

    # Temporary stub completion for all
    compdef __lazy_symfony_composer composer __icomposer vcomposer  
    compdef __lazy_symfony_valet valet
    compdef __lazy_symfony_phpactor phpactor
fi

compdef _op op

#- Source late files --------------------------------------------------------------------------------------------------#

(( ${+DOT_AFTER_INIT_SOURCES} )) && safe_source "${DOT_AFTER_INIT_SOURCES[@]}"

#- Display flashy, painstakingly crafted intro screen & Prompt -------------------------------------------------------#

if [[ -o login ]] && [[ -t 0 ]]; then
    (( DOT_PROMPT_HEIGHT )) || export DOT_PROMPT_HEIGHT=2
    (( ${+MYVIMRC} )) && export LOL_MSG=$DOT_NEOVIM_LOL_MSG || export LOL_MSG=$DOT_DEFAULT_LOL_MSG
    [ -f "$HOME"/.lolmsgrc ] && . "$HOME"/.lolmsgrc || echo 'export LOLMSGRC_ENABLED=1' > "$HOME"/.lolmsgrc
    [[ "$LOLMSGRC_ENABLED" -eq 1 ]] && lolmsg "$LOL_MSG" "$DOT_PROMPT_HEIGHT"
fi

source ${ZDOTDIR}/aliases
source ${ZDOTDIR}/prompt/prompt

autoload -Uz edit-command-line
zle -N edit-command-line
bindkey '^x' edit-command-line

#- Init mcfly history last -------------------------------------------------------------------------------------------#

_evalcache mcfly init zsh

# Override mcfly's precmd to background the expensive `mcfly add` binary invocation.
# The exit code capture and fc -W stay synchronous (cheap), only the database write is deferred.
if (( ${+functions[mcfly_prompt_command]} )); then
    mcfly_prompt_command() {
        local exit_code=$?

        if [[ ! -f "${MCFLY_HISTORY}" ]]; then
            export MCFLY_HISTORY=$(command mktemp ${TMPDIR:-/tmp}/mcfly.XXXXXXXX)
            command tail -n100 "${MCFLY_HISTFILE}" >| ${MCFLY_HISTORY}
        fi

        fc -W "${MCFLY_HISTORY}"

        # Background the expensive binary call â€” database write doesn't need to block the prompt.
        $MCFLY_PATH --history_format $MCFLY_HISTORY_FORMAT add --exit ${exit_code} &!

        return ${exit_code}
    }
fi

#- And finally, unfunc locally used functions ------------------------------------------------------------------------#

unfunction _evalcache
unfunction __fpath_add
unfunction __path_add
unfunction __autoload

