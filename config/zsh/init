#!/usr/bin/env zsh

#---------------------------------------------------------------------------------------------------------------------#
# By Jascha030                                       Dotfiles                   https://github.io/jascha030/.dotfiles #
#---------------------------------------------------------------------------------------------------------------------#

#- Internally used functions -----------------------------------------------------------------------------------------#

__fpath_add() {
    fpath=( "$@" "${fpath[@]}" )
}

__path_add() {
    path=( "$@" "${path[@]}" )
}

__autoload() {
    local a

    for a in "$@"; do
        [[ -d "$a" ]] && autoload -Uz "$a"/*(.:t)
    done
}

# Credits to: https://github.com/mroth/evalcache
_evalcache() {
    local data name cmdHash="nohash"
    data="$*"

    # Use first non-assignment argument as command name
    for name in "$@"; do
        if [[ "$name" != [A-Za-z_][A-Za-z0-9_]*=* ]]; then
            break
        fi
    done

    # If command is a function, include its definition in hash data
    if typeset -f "$name" > /dev/null 2>&1; then
        data+=$(typeset -f "$name")
    fi

    # Prefer zsh builtin digest (fastest, no external process)
    if zmodload -e zsh/digest 2>/dev/null || zmodload zsh/digest 2>/dev/null; then
        cmdHash=$(print -rn -- "$data" | digest md5)
    elif command -v md5 > /dev/null 2>&1; then
        cmdHash=$(printf "%s" "$data" | md5)
    elif command -v md5sum > /dev/null 2>&1; then
        cmdHash=$(printf "%s" "$data" | md5sum | cut -d' ' -f1)
    fi

    local cacheFile="${ZSH_EVALCACHE_DIR}/init-${name##*/}-${cmdHash}.sh"

    if [[ "$ZSH_EVALCACHE_DISABLE" == "true" ]]; then
        "$@"
        return
    fi

    if [[ -s "$cacheFile" ]]; then
        source "$cacheFile"
        return
    fi

    if command -v "$name" > /dev/null 2>&1; then
        echo "evalcache: caching output of: $*" >&2
        mkdir -p "$ZSH_EVALCACHE_DIR"
        "$@" > "$cacheFile"
        source "$cacheFile"
    else
        echo "evalcache: ERROR: ${name} not found in PATH" >&2
        return 1
    fi
}

_evalcache_clear() {
    rm -i "$ZSH_EVALCACHE_DIR"/init-*.sh
}

#- Init --------------------------------------------------------------------------------------------------------------#

# Homebrew environment
_evalcache /opt/homebrew/bin/brew shellenv

path=(
    "${DOT_PATH_VAR[@]}"
    "${path[@]}"
    "$HOME/.composer/vendor/bin"
)
typeset -aU path

if (( ${+DOT_COMP_DIRS} )); then
    __fpath_add "${DOT_COMP_DIRS[@]}"
fi

__fpath_add "${ZDOTDIR}/zfunc" "${ZDOTDIR}/completions"
__autoload "${ZDOTDIR}/zfunc"
__fpath_add "/opt/homebrew/share/zsh/site-functions"

# Run (bash)compinit for completions.
autoload -Uz compinit
if [[ -n ${ZDOTDIR:-~}/.zcompdump(#qN.mh+24) ]]; then
    compinit -i
else
    compinit -C -i
fi

# Source files that are required early.
(( ${+DOT_SOURCES} )) && safe_source "${DOT_SOURCES[@]}"

autoload -U +X bashcompinit && bashcompinit
(( ${+DOT_BASH_COMPLETIONS})) && safe_source "${DOT_BASH_COMPLETIONS[@]}"

# Load plugins.
safe_source "$ZDOTDIR"/plugins-spec
[[ "$ZDOTDIR"/.zcompdump.zwc -nt "$ZDOTDIR"/.zcompdump ]] || zcompile_many "$ZDOTDIR"/.zcompdump
unfunction zcompile_many

# Assure required dirs and files exist.
(( ${+DOT_REQUIRED_DIRS} )) && assert_dirs "${DOT_REQUIRED_DIRS[@]}"
(( ${+DOT_REQUIRED_FILES} )) && assert_files "${DOT_REQUIRED_FILES[@]}"

export ZSH_AUTOSUGGEST_MANUAL_REBIND=1

#- Application init evaluations --------------------------------------------------------------------------------------#

_evalcache zoxide init zsh
_evalcache op completion zsh

compdef _op op

#- Lazy-load comp/cmd/env's that aren't often required but add a lot to start-up time --------------------------------#

source ${ZDOTDIR}/lazyfunctions

#- Source late files --------------------------------------------------------------------------------------------------#

(( ${+DOT_AFTER_INIT_SOURCES} )) && safe_source "${DOT_AFTER_INIT_SOURCES[@]}"

#- Display flashy, painstakingly crafted intro screen & Prompt -------------------------------------------------------#

if [[ -o login ]] && [[ -t 0 ]]; then
    (( DOT_PROMPT_HEIGHT )) || export DOT_PROMPT_HEIGHT=2
    (( ${+MYVIMRC} )) && export LOL_MSG=$DOT_NEOVIM_LOL_MSG || export LOL_MSG=$DOT_DEFAULT_LOL_MSG
    [ -f "$HOME"/.lolmsgrc ] && . "$HOME"/.lolmsgrc || echo 'export LOLMSGRC_ENABLED=1' > "$HOME"/.lolmsgrc
    [[ "$LOLMSGRC_ENABLED" -eq 1 ]] && lolmsg "$LOL_MSG" "$DOT_PROMPT_HEIGHT"
fi

source ${ZDOTDIR}/aliases
source ${ZDOTDIR}/prompt/prompt

#- Init mcfly history last -------------------------------------------------------------------------------------------#

_evalcache mcfly init zsh

# Override mcfly's precmd to background the expensive `mcfly add` binary invocation.
# The exit code capture and fc -W stay synchronous (cheap), only the database write is deferred.
if (( ${+functions[mcfly_prompt_command]} )); then
    mcfly_prompt_command() {
        local exit_code=$?

        if [[ ! -f "${MCFLY_HISTORY}" ]]; then
            export MCFLY_HISTORY=$(command mktemp ${TMPDIR:-/tmp}/mcfly.XXXXXXXX)
            command tail -n100 "${MCFLY_HISTFILE}" >| ${MCFLY_HISTORY}
        fi

        fc -W "${MCFLY_HISTORY}"

        # Background the expensive binary call â€” database write doesn't need to block the prompt.
        $MCFLY_PATH --history_format $MCFLY_HISTORY_FORMAT add --exit ${exit_code} &!

        return ${exit_code}
    }
fi

#- And finally, unfunc locally used functions ------------------------------------------------------------------------#

unfunction _evalcache
unfunction __fpath_add
unfunction __path_add
unfunction __autoload
